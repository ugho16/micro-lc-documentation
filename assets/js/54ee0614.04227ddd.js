"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[5945],{5858:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>u});var o=n(6687);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},s=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),d=c(n),u=r,f=d["".concat(l,".").concat(u)]||d[u]||m[u]||i;return n?o.createElement(f,a(a({ref:t},s),{},{components:n})):o.createElement(f,a({ref:t},s))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=d;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:r,a[1]=p;for(var c=2;c<i;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2308:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>p,metadata:()=>c,toc:()=>m});var o=n(6428),r=n(8920),i=(n(6687),n(5858)),a=["components"],p={title:"Composer API",description:"micro-lc composer API",sidebar_label:"Composer API",sidebar_position:30},l=void 0,c={unversionedId:"api/composer-api",id:"api/composer-api",title:"Composer API",description:"micro-lc composer API",source:"@site/docs/api/composer-api.md",sourceDirName:"api",slug:"/api/composer-api",permalink:"/documentation/api/composer-api",draft:!1,editUrl:"https://github.com/micro-lc/documentation/edit/main/docs/api/composer-api.md",tags:[],version:"current",lastUpdatedBy:"epessina",sidebarPosition:30,frontMatter:{title:"Composer API",description:"micro-lc composer API",sidebar_label:"Composer API",sidebar_position:30},sidebar:"api",previous:{title:"Extensions",permalink:"/documentation/api/micro-lc-api/extensions"}},s={},m=[{value:"<code>premount</code>",id:"premount",level:3},{value:"<code>createComposerContext</code>",id:"createcomposercontext",level:3},{value:"<code>render</code>",id:"render",level:3}],d={toc:m};function u(e){var t=e.components,n=(0,r.Z)(e,a);return(0,i.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Any HTML element mounted in ",(0,i.kt)("micro-lc",null)," via ",(0,i.kt)("a",{parentName:"p",href:"/documentation/docs/guides/layout"},"layout")," or\n",(0,i.kt)("a",{parentName:"p",href:"/documentation/docs/guides/layout#mount-point"},"mount point"),", or any\n",(0,i.kt)("a",{parentName:"p",href:"/documentation/docs/guides/applications/compose"},"composable application")," is provided with the property ",(0,i.kt)("inlineCode",{parentName:"p"},"composerApi"),", which\nprovides the same dynamic capability for ",(0,i.kt)("a",{parentName:"p",href:"/documentation/docs/concepts/composition"},"mounting HTML subtrees")," ",(0,i.kt)("micro-lc",null),"\nitself uses under the hood."),(0,i.kt)("p",null,"The composer API is an object with two methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"premount")," which flattens polymorphic configurations and injects import maps, and"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"createComposerContext")," which builds an appender that can be called by assigning a root HTML DOM appending the\ndynamically configured HTML DOM as subtree of the root."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"render")," wraps ",(0,i.kt)("inlineCode",{parentName:"li"},"lit-html")," ",(0,i.kt)("inlineCode",{parentName:"li"},"render")," method and injects a ",(0,i.kt)("a",{parentName:"li",href:"/documentation/docs/guides/applications/compose#properties-injection"},"context"))),(0,i.kt)("h3",{id:"premount"},(0,i.kt)("inlineCode",{parentName:"h3"},"premount")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ComposerApi {\n  // ... rest of the API\n  premount: (config: PluginConfiguration, proxyWindow?: ImportShimContext) => Promise<ResolvedConfig>\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"premount")," allows to reduce the\n",(0,i.kt)("a",{parentName:"p",href:"localhost:3000/docs/guides/applications/compose#plugin-configuration"},(0,i.kt)("inlineCode",{parentName:"a"},"PluginConfiguration")," type")," to the following\n",(0,i.kt)("inlineCode",{parentName:"p"},"ResolvedConfig")," type"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ResolvedConfig {\n  content: Content\n  sources: {\n    importmap?: ImportMap\n    uris: string[]\n  }\n}\n")),(0,i.kt)("p",null,"the optional ",(0,i.kt)("inlineCode",{parentName:"p"},"proxyWindow")," which defaults to the current ",(0,i.kt)("inlineCode",{parentName:"p"},"window")," must implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"importShim")," interface, allows\nto override the importmap features, namely to set a no-op behaviour or select an iframe window. Notice that the\ninterface is equivalent to"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ImportShimContext {\n  importShim<D, E extends Record<string, unknown>>(\n    uri: string, parentUrl?: string\n  ): Promise<{ default: D } & E>\n}\n")),(0,i.kt)("p",null,"After being called, ",(0,i.kt)("inlineCode",{parentName:"p"},"premount")," ensures all import maps declared are available and ",(0,i.kt)("inlineCode",{parentName:"p"},"uris")," sources have been fetched and\ntheir code run. If there is no ",(0,i.kt)("inlineCode",{parentName:"p"},"sources")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"PluginConfiguration"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"premount")," is a no-operation."),(0,i.kt)("h3",{id:"createcomposercontext"},(0,i.kt)("inlineCode",{parentName:"h3"},"createComposerContext")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ComposerApi {\n  // ... rest of the API\n  createComposerContext: (\n    content: Content,\n    options: ComposerOptions\n  ) => Promise<ComposerContextAppender>\n}\n")),(0,i.kt)("p",null,"Once ",(0,i.kt)("inlineCode",{parentName:"p"},"premount")," has been run, if needed, ",(0,i.kt)("inlineCode",{parentName:"p"},"createComposerContext")," provides a callback for appending the DOM\nconfigured in ",(0,i.kt)("inlineCode",{parentName:"p"},"content"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"type ComposerContextAppender = (container: HTMLElement | DocumentFragment, options?: RenderOptions) => void\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"container")," is the root element that will be used to append the composed subtree and ",(0,i.kt)("inlineCode",{parentName:"p"},"options"),"\nrefer to optional features provided by the ",(0,i.kt)("a",{parentName:"p",href:"https://lit.dev/docs/api/templates/#render"},(0,i.kt)("inlineCode",{parentName:"a"},"lit-html")," ",(0,i.kt)("inlineCode",{parentName:"a"},"render")," method"),"."),(0,i.kt)("p",null,"Finally, ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"createComposerContext")," is the object to interact with when the compiler needs to be\ninstructed to recognize some properties as special context. This feature allows to inject JS context avoiding eval and\nworks according to the ",(0,i.kt)("a",{parentName:"p",href:"/documentation/docs/guides/applications/compose#interpolated-properties"},"composability principles"),"."),(0,i.kt)("h3",{id:"render"},(0,i.kt)("inlineCode",{parentName:"h3"},"render")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ComposerApi {\n  // ... rest of the API\n  render: (\n    config: ResolvedConfig,\n    container: HTMLElement,\n    context: Record<string, unknown> = {}\n  ) => Promise<ComposerContextAppender>\n}\n")),(0,i.kt)("p",null,"Alternatively, if the use case requires to append a ",(0,i.kt)("inlineCode",{parentName:"p"},"ResolvedConfig")," to a ",(0,i.kt)("inlineCode",{parentName:"p"},"container")," html element\nand inject a ",(0,i.kt)("inlineCode",{parentName:"p"},"context")," of properties, ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," provides a useful shortcut."))}u.isMDXComponent=!0}}]);